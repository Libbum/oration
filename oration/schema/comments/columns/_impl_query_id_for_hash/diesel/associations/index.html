<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `associations` mod in crate `oration`."><meta name="keywords" content="rust, rustlang, rust-lang, associations"><title>oration::schema::comments::columns::_impl_query_id_for_hash::diesel::associations - Rust</title><link rel="stylesheet" type="text/css" href="../../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../../../../../light.css" id="themeStyle"><script src="../../../../../../../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Module associations</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#traits">Traits</a></li></ul></div><p class='location'><a href='../../../../../../index.html'>oration</a>::<wbr><a href='../../../../../index.html'>schema</a>::<wbr><a href='../../../../index.html'>comments</a>::<wbr><a href='../../../index.html'>columns</a>::<wbr><a href='../../index.html'>_impl_query_id_for_hash</a>::<wbr><a href='../index.html'>diesel</a></p><script>window.sidebarCurrent = {name: 'associations', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../../../../../../settings.html"><img src="../../../../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span></span><span class='in-band'>Module <a href='../../../../../../index.html'>oration</a>::<wbr><a href='../../../../../index.html'>schema</a>::<wbr><a href='../../../../index.html'>comments</a>::<wbr><a href='../../../index.html'>columns</a>::<wbr><a href='../../index.html'>_impl_query_id_for_hash</a>::<wbr><a href='../index.html'>diesel</a>::<wbr><a class="mod" href=''>associations</a></span></h1><div class='docblock'><p>Traits related to relationships between multiple tables.</p>
<p>Associations in Diesel are always child-to-parent.
You can declare an association between two records with <code>#[belongs_to]</code>.
Unlike other ORMs, Diesel has no concept of <code>#[has_many</code>]</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">schema</span>::{<span class="ident">posts</span>, <span class="ident">users</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Identifiable</span>, <span class="ident">Queryable</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">table_name</span> <span class="op">=</span> <span class="string">&quot;users&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">User</span> {
    <span class="ident">id</span>: <span class="ident">i32</span>,
    <span class="ident">name</span>: <span class="ident">String</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Identifiable</span>, <span class="ident">Queryable</span>, <span class="ident">Associations</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">belongs_to</span>(<span class="ident">User</span>)]</span>
<span class="attribute">#[<span class="ident">table_name</span> <span class="op">=</span> <span class="string">&quot;posts&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Post</span> {
    <span class="ident">id</span>: <span class="ident">i32</span>,
    <span class="ident">user_id</span>: <span class="ident">i32</span>,
    <span class="ident">title</span>: <span class="ident">String</span>,
}

<span class="kw">let</span> <span class="ident">user</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">find</span>(<span class="number">2</span>).<span class="ident">get_result</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">users_post</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">user</span>)
    .<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">3</span>, <span class="ident">user_id</span>: <span class="number">2</span>, <span class="ident">title</span>: <span class="string">&quot;My first post too&quot;</span>.<span class="ident">into</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected</span>, <span class="ident">users_post</span>);</pre>
<p>Note that in addition to the <code>#[belongs_to]</code> annotation, we also need to
<code>#[derive(Associations)]</code></p>
<p><code>#[belongs_to]</code> is given the name of the struct that represents the parent.
Both the parent and child must implement <a href="trait.Identifiable.html"><code>Identifiable</code></a>.
The struct given to <code>#[belongs_to]</code> must be in scope,
so you will need <code>use some_module::User</code> if <code>User</code> is defined in another module.</p>
<p>By default, Diesel assumes that your foreign keys will follow the convention <code>table_name_id</code>.
If your foreign key has a different name,
you can provide the <code>foreign_key</code> argument to <code>#[belongs_to]</code>.
For example, <code>#[belongs_to(Foo, foreign_key = &quot;mykey&quot;)]</code>.</p>
<p>Associated data is typically loaded in multiple queries (one query per table).
This is usually more efficient than using a join,
especially if 3 or more tables are involved.
For most datasets,
using a join to load in a single query transmits so much duplicate data
that it costs more time than the extra round trip would have.</p>
<p>You can load the children for one or more parents using
<a href="../query_dsl/trait.BelongingToDsl.html#tymethod.belonging_to"><code>belonging_to</code></a></p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">user</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">find</span>(<span class="number">1</span>).<span class="ident">first</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>).<span class="ident">expect</span>(<span class="string">&quot;Error loading user&quot;</span>);
<span class="kw">let</span> <span class="ident">post_list</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">user</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">Post</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;Error loading posts&quot;</span>);
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;My first post&quot;</span>.<span class="ident">to_string</span>() },
    <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;About Rust&quot;</span>.<span class="ident">to_string</span>() },
];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">post_list</span>, <span class="ident">expected</span>);</pre>
<p>If you're coming from other ORMs, you'll notice that this design is quite different from most.
There you would have an instance method on the parent, or have the children stored somewhere on
the posts. This design leads to many problems, including <a href="https://stackoverflow.com/q/97197/1254484">N+1 query
bugs</a>, and runtime errors when accessing an
association that isn't there.</p>
<p>In Diesel, data and its associations are considered to be separate. If you want to pass around
a user and all of its posts, that type is <code>(User, Vec&lt;Post&gt;)</code>.</p>
<p>Next lets look at how to load the children for more than one parent record.
[<code>belonging_to</code>][belonging-to] can be used to load the data, but we'll also need to group it
with its parents. For this we use an additional method <a href="trait.GroupedBy.html#tymethod.grouped_by"><code>grouped_by</code></a></p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">sean</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">filter</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Sean&quot;</span>)).<span class="ident">first</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">tess</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">filter</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Tess&quot;</span>)).<span class="ident">first</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">seans_posts</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">sean</span>)
    .<span class="ident">select</span>(<span class="ident">title</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;My first post&quot;</span>, <span class="string">&quot;About Rust&quot;</span>], <span class="ident">seans_posts</span>);

<span class="comment">// A vec or slice can be passed as well</span>
<span class="kw">let</span> <span class="ident">more_posts</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[<span class="ident">sean</span>, <span class="ident">tess</span>])
    .<span class="ident">select</span>(<span class="ident">title</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;My first post&quot;</span>, <span class="string">&quot;About Rust&quot;</span>, <span class="string">&quot;My first post too&quot;</span>], <span class="ident">more_posts</span>);</pre>
<p>Typically you will want to group up the children with their parents.
In other ORMs, this is often called a <code>has_many</code> relationship.
Diesel provides support for doing this grouping, once the data has been
loaded.</p>
<p>[<code>grouped_by</code>] is called on a <code>Vec&lt;Child&gt;</code> with a <code>&amp;[Parent]</code>.
The return value will be <code>Vec&lt;Vec&lt;Child&gt;&gt;</code> indexed to match their parent.
Or to put it another way, the returned data can be passed to <code>zip</code>,
and it will be combined with its parent.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">users</span> <span class="op">=</span> <span class="ident">users</span>::<span class="ident">table</span>.<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">posts</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">users</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">Post</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>
    .<span class="ident">grouped_by</span>(<span class="kw-2">&amp;</span><span class="ident">users</span>);
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">into_iter</span>().<span class="ident">zip</span>(<span class="ident">posts</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;&gt;</span>();

<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (
        <span class="ident">User</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">name</span>: <span class="string">&quot;Sean&quot;</span>.<span class="ident">into</span>() },
        <span class="macro">vec</span><span class="macro">!</span>[
            <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;My first post&quot;</span>.<span class="ident">into</span>() },
            <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;About Rust&quot;</span>.<span class="ident">into</span>() },
        ],
    ),
    (
        <span class="ident">User</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">name</span>: <span class="string">&quot;Tess&quot;</span>.<span class="ident">into</span>() },
        <span class="macro">vec</span><span class="macro">!</span>[
            <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">3</span>, <span class="ident">user_id</span>: <span class="number">2</span>, <span class="ident">title</span>: <span class="string">&quot;My first post too&quot;</span>.<span class="ident">into</span>() },
        ],
    ),
];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected_data</span>, <span class="ident">data</span>);</pre>
<p><code>grouped_by</code> can be called multiple times
if you have multiple children or grandchildren.</p>
<p>For example, this code will load some users,
all of their posts,
and all of the comments on those posts.
Explicit type annotations have been added
to make each line a bit more clear.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">users</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">users</span>::<span class="ident">table</span>.<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;error loading users&quot;</span>);
<span class="kw">let</span> <span class="ident">posts</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Post</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Post</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">users</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">Post</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;error loading posts&quot;</span>);
<span class="kw">let</span> <span class="ident">comments</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Comment</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Comment</span>::<span class="ident">belonging_to</span>(<span class="kw-2">&amp;</span><span class="ident">posts</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">Comment</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;Error loading comments&quot;</span>);
<span class="kw">let</span> <span class="ident">grouped_comments</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Comment</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">comments</span>.<span class="ident">grouped_by</span>(<span class="kw-2">&amp;</span><span class="ident">posts</span>);
<span class="kw">let</span> <span class="ident">posts_and_comments</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">Post</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Comment</span><span class="op">&gt;</span>)<span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">posts</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">zip</span>(<span class="ident">grouped_comments</span>)
    .<span class="ident">grouped_by</span>(<span class="kw-2">&amp;</span><span class="ident">users</span>);
<span class="kw">let</span> <span class="ident">result</span>: <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">User</span>, <span class="ident">Vec</span><span class="op">&lt;</span>(<span class="ident">Post</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Comment</span><span class="op">&gt;</span>)<span class="op">&gt;</span>)<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">users</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">zip</span>(<span class="ident">posts_and_comments</span>)
    .<span class="ident">collect</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (
        <span class="ident">User</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">name</span>: <span class="string">&quot;Sean&quot;</span>.<span class="ident">to_string</span>() },
        <span class="macro">vec</span><span class="macro">!</span>[
            (
                <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;My first post&quot;</span>.<span class="ident">to_string</span>() },
                <span class="macro">vec</span><span class="macro">!</span>[ <span class="ident">Comment</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">post_id</span>: <span class="number">1</span>, <span class="ident">body</span>: <span class="string">&quot;Great post&quot;</span>.<span class="ident">to_string</span>() } ]
            ),
            (
                <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">user_id</span>: <span class="number">1</span>, <span class="ident">title</span>: <span class="string">&quot;About Rust&quot;</span>.<span class="ident">to_string</span>() },
                <span class="macro">vec</span><span class="macro">!</span>[
                    <span class="ident">Comment</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">post_id</span>: <span class="number">2</span>, <span class="ident">body</span>: <span class="string">&quot;Yay! I am learning Rust&quot;</span>.<span class="ident">to_string</span>() }
                ]

            )
        ]
    ),
    (
        <span class="ident">User</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">name</span>: <span class="string">&quot;Tess&quot;</span>.<span class="ident">to_string</span>() },
        <span class="macro">vec</span><span class="macro">!</span>[
            (
                <span class="ident">Post</span> { <span class="ident">id</span>: <span class="number">3</span>, <span class="ident">user_id</span>: <span class="number">2</span>, <span class="ident">title</span>: <span class="string">&quot;My first post too&quot;</span>.<span class="ident">to_string</span>() },
                <span class="macro">vec</span><span class="macro">!</span>[ <span class="ident">Comment</span> { <span class="ident">id</span>: <span class="number">3</span>, <span class="ident">post_id</span>: <span class="number">3</span>, <span class="ident">body</span>: <span class="string">&quot;I enjoyed your post&quot;</span>.<span class="ident">to_string</span>() } ]
            )
        ]
    )
];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="ident">expected</span>);</pre>
<p>And that's it.
It may seem odd to have load, group, and zip be explicit separate steps
if you are coming from another ORM.
However, the goal is to provide simple building blocks which can
be used to construct the complex behavior applications need.</p>
</div><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.BelongsTo.html"
                                  title='trait oration::schema::comments::columns::_impl_query_id_for_hash::diesel::associations::BelongsTo'>BelongsTo</a></td>
                           <td class='docblock-short'>
                                <p>Indicates that a type belongs to <code>Parent</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.GroupedBy.html"
                                  title='trait oration::schema::comments::columns::_impl_query_id_for_hash::diesel::associations::GroupedBy'>GroupedBy</a></td>
                           <td class='docblock-short'>
                                <p>The <code>grouped_by</code> function groups records by their parent.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.HasTable.html"
                                  title='trait oration::schema::comments::columns::_impl_query_id_for_hash::diesel::associations::HasTable'>HasTable</a></td>
                           <td class='docblock-short'>
                                <p>This trait indicates that a struct is associated with a single database table.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Identifiable.html"
                                  title='trait oration::schema::comments::columns::_impl_query_id_for_hash::diesel::associations::Identifiable'>Identifiable</a></td>
                           <td class='docblock-short'>
                                <p>This trait indicates that a struct represents a single row in a database table.</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../../../../../";window.currentCrate = "oration";</script><script src="../../../../../../../aliases.js"></script><script src="../../../../../../../main.js"></script><script defer src="../../../../../../../search-index.js"></script></body></html>