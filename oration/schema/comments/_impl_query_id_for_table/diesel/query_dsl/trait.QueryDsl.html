<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `QueryDsl` trait in crate `oration`."><meta name="keywords" content="rust, rustlang, rust-lang, QueryDsl"><title>oration::schema::comments::_impl_query_id_for_table::diesel::query_dsl::QueryDsl - Rust</title><link rel="stylesheet" type="text/css" href="../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../../../../light.css" id="themeStyle"><script src="../../../../../../storage.js"></script></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Trait QueryDsl</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.distinct">distinct</a><a href="#method.select">select</a><a href="#method.count">count</a><a href="#method.inner_join">inner_join</a><a href="#method.left_outer_join">left_outer_join</a><a href="#method.left_join">left_join</a><a href="#method.filter">filter</a><a href="#method.or_filter">or_filter</a><a href="#method.find">find</a><a href="#method.order">order</a><a href="#method.order_by">order_by</a><a href="#method.then_order_by">then_order_by</a><a href="#method.limit">limit</a><a href="#method.offset">offset</a><a href="#method.for_update">for_update</a><a href="#method.for_no_key_update">for_no_key_update</a><a href="#method.for_share">for_share</a><a href="#method.for_key_share">for_key_share</a><a href="#method.skip_locked">skip_locked</a><a href="#method.no_wait">no_wait</a><a href="#method.into_boxed">into_boxed</a><a href="#method.single_value">single_value</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../../../../../index.html'>oration</a>::<wbr><a href='../../../../index.html'>schema</a>::<wbr><a href='../../../index.html'>comments</a>::<wbr><a href='../../index.html'>_impl_query_id_for_table</a>::<wbr><a href='../index.html'>diesel</a>::<wbr><a href='index.html'>query_dsl</a></p><script>window.sidebarCurrent = {name: 'QueryDsl', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../../../../../settings.html"><img src="../../../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span></span><span class='in-band'>Trait <a href='../../../../../index.html'>oration</a>::<wbr><a href='../../../../index.html'>schema</a>::<wbr><a href='../../../index.html'>comments</a>::<wbr><a href='../../index.html'>_impl_query_id_for_table</a>::<wbr><a href='../index.html'>diesel</a>::<wbr><a href='index.html'>query_dsl</a>::<wbr><a class="trait" href=''>QueryDsl</a></span></h1><div class="docblock type-decl"><pre class='rust trait'>pub trait QueryDsl {
    fn <a href='#method.distinct' class='fnname'>distinct</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: DistinctDsl</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.select' class='fnname'>select</a>&lt;Selection&gt;(self, selection: Selection) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selection: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: SelectDsl&lt;Selection&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.count' class='fnname'>count</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: SelectDsl&lt;CountStar&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.inner_join' class='fnname'>inner_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, Inner&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.left_outer_join' class='fnname'>left_outer_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, LeftOuter&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.left_join' class='fnname'>left_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, LeftOuter&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.filter' class='fnname'>filter</a>&lt;Predicate&gt;(self, predicate: Predicate) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: FilterDsl&lt;Predicate&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.or_filter' class='fnname'>or_filter</a>&lt;Predicate&gt;(self, predicate: Predicate) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: OrFilterDsl&lt;Predicate&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.find' class='fnname'>find</a>&lt;PK&gt;(self, id: PK) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: FindDsl&lt;PK&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.order' class='fnname'>order</a>&lt;Expr&gt;(self, expr: Expr) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expr: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: OrderDsl&lt;Expr&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.order_by' class='fnname'>order_by</a>&lt;Expr&gt;(self, expr: Expr) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expr: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: OrderDsl&lt;Expr&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.then_order_by' class='fnname'>then_order_by</a>&lt;Order&gt;(self, order: Order) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: ThenOrderDsl&lt;Order&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.limit' class='fnname'>limit</a>(self, limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: LimitDsl</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.offset' class='fnname'>offset</a>(self, offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: OffsetDsl</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.for_update' class='fnname'>for_update</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: ForUpdateDsl</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.for_no_key_update' class='fnname'>for_no_key_update</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForNoKeyUpdate&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.for_share' class='fnname'>for_share</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForShare&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.for_key_share' class='fnname'>for_key_share</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForKeyShare&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.skip_locked' class='fnname'>skip_locked</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: ModifyLockDsl&lt;SkipLocked&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.no_wait' class='fnname'>no_wait</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: ModifyLockDsl&lt;NoWait&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.into_boxed' class='fnname'>into_boxed</a>&lt;'a, DB&gt;(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DB: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/backend/trait.Backend.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::backend::Backend">Backend</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: BoxedDsl&lt;'a, DB&gt;</span>,
    { ... }
<div class='item-spacer'></div>    fn <a href='#method.single_value' class='fnname'>single_value</a>(self) -&gt; Self::Output<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: SingleValueDsl</span>,
    { ... }
}</pre></div><div class='docblock'><p>Methods used to construct select statements.</p>
</div>
            <h2 id='provided-methods' class='small-section-header'>
              Provided Methods<a href='#provided-methods' class='anchor'></a>
            </h2>
            <div class='methods'>
        <h3 id='method.distinct' class='method'><span id='distinct.v' class='invisible'><code>fn <a href='#method.distinct' class='fnname'>distinct</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: DistinctDsl,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds the <code>DISTINCT</code> keyword to a query.</p>
<p>This method will override any previous distinct clause that was present.
For example, on PostgreSQL, <code>foo.distinct_on(bar).distinct()</code> will
create the same query as <code>foo.distinct()</code>.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">users</span>)
    .<span class="ident">values</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Sean&quot;</span>); <span class="number">3</span>])
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">names</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>).<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">distinct_names</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>).<span class="ident">distinct</span>().<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>; <span class="number">3</span>], <span class="ident">names</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>; <span class="number">1</span>], <span class="ident">distinct_names</span>);</pre>
</div><h3 id='method.select' class='method'><span id='select.v' class='invisible'><code>fn <a href='#method.select' class='fnname'>select</a>&lt;Selection&gt;(self, selection: Selection) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Selection: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: SelectDsl&lt;Selection&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds a <code>SELECT</code> clause to the query.</p>
<p>If there was already a select clause present, it will be overridden.
For example, <code>foo.select(bar).select(baz)</code> will produce the same
query as <code>foo.select(baz)</code>.</p>
<p>By default, the select clause will be roughly equivalent to <code>SELECT *</code>
(however, Diesel will list all columns to ensure that they are in the
order we expect).</p>
<p><code>select</code> has slightly stricter bounds on its arguments than other
methods. In particular, when used with a left outer join, <code>.nullable</code>
must be called on columns that come from the right side of a join. It
can be called on the column itself, or on an expression containing that
column. <code>title.nullable()</code>, <code>lower(title).nullable()</code>, and <code>(id, title).nullable()</code> would all be valid.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="comment">// By default, all columns will be selected</span>
<span class="kw">let</span> <span class="ident">all_users</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">load</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">String</span>)<span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[(<span class="number">1</span>, <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>)), (<span class="number">2</span>, <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Tess&quot;</span>))], <span class="ident">all_users</span>);

<span class="kw">let</span> <span class="ident">all_names</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>).<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>, <span class="string">&quot;Tess&quot;</span>], <span class="ident">all_names</span>);</pre>
<h3 id="when-used-with-a-left-join" class="section-header"><a href="#when-used-with-a-left-join">When used with a left join</a></h3>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">join</span> <span class="op">=</span> <span class="ident">users</span>::<span class="ident">table</span>.<span class="ident">left_join</span>(<span class="ident">posts</span>::<span class="ident">table</span>);

<span class="comment">// By default, all columns from both tables are selected</span>
<span class="kw">let</span> <span class="ident">all_data</span> <span class="op">=</span> <span class="ident">join</span>.<span class="ident">load</span>::<span class="op">&lt;</span>(<span class="ident">User</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Post</span><span class="op">&gt;</span>)<span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">User</span>::<span class="ident">new</span>(<span class="number">1</span>, <span class="string">&quot;Sean&quot;</span>), <span class="prelude-val">Some</span>(<span class="ident">Post</span>::<span class="ident">new</span>(<span class="ident">post_id</span>, <span class="number">1</span>, <span class="string">&quot;Sean&#39;s Post&quot;</span>))),
    (<span class="ident">User</span>::<span class="ident">new</span>(<span class="number">2</span>, <span class="string">&quot;Tess&quot;</span>), <span class="prelude-val">None</span>),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected_data</span>, <span class="ident">all_data</span>);

<span class="comment">// Since `posts` is on the right side of a left join, `.nullable` is</span>
<span class="comment">// needed.</span>
<span class="kw">let</span> <span class="ident">names_and_titles</span> <span class="op">=</span> <span class="ident">join</span>.<span class="ident">select</span>((<span class="ident">users</span>::<span class="ident">name</span>, <span class="ident">posts</span>::<span class="ident">title</span>.<span class="ident">nullable</span>()))
    .<span class="ident">load</span>::<span class="op">&lt;</span>(<span class="ident">String</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>)<span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>), <span class="prelude-val">Some</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&#39;s Post&quot;</span>))),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Tess&quot;</span>), <span class="prelude-val">None</span>),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected_data</span>, <span class="ident">names_and_titles</span>);</pre>
</div><h3 id='method.count' class='method'><span id='count.v' class='invisible'><code>fn <a href='#method.count' class='fnname'>count</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: SelectDsl&lt;CountStar&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Get the count of a query. This is equivalent to <code>.select(count_star())</code></p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">count</span>().<span class="ident">get_result</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="ident">count</span>);</pre>
</div><h3 id='method.inner_join' class='method'><span id='inner_join.v' class='invisible'><code>fn <a href='#method.inner_join' class='fnname'>inner_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, Inner&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Join two tables using a SQL <code>INNER JOIN</code>.</p>
<p>If you have invoked <a href="../macro.joinable.html"><code>joinable!</code></a> for the two tables, you can pass that
table directly.  Otherwise you will need to use <a href="trait.JoinOnDsl.html#method.on"><code>.on</code></a> to specify the <code>ON</code>
clause.</p>
<p>You can join to as many tables as you'd like in a query, with the
restriction that no table can appear in the query more than once. The reason
for this restriction is that one of the appearances would require aliasing,
and we do not currently have a fleshed out story for dealing with table
aliases.</p>
<p>You will also need to call <a href="../macro.allow_tables_to_appear_in_same_query.html"><code>allow_tables_to_appear_in_same_query!</code></a>.
If you are using <code>infer_schema!</code> or <code>diesel print-schema</code>, this will
have been generated for you.
See the documentation for <a href="../macro.allow_tables_to_appear_in_same_query.html"><code>allow_tables_to_appear_in_same_query!</code></a> for
details.</p>
<p>Diesel expects multi-table joins to be semantically grouped based on the
relationships. For example, <code>users.inner_join(posts.inner_join(comments))</code>
is not the same as <code>users.inner_join(posts).inner_join(comments)</code>. The first
would deserialize into <code>(User, (Post, Comment))</code> and generate the following
SQL:</p>
<pre><code class="language-sql">SELECT * FROM users
    INNER JOIN posts ON posts.user_id = users.id
    INNER JOIN comments ON comments.post_id = posts.id
</code></pre>
<p>While the second query would deserialize into <code>(User, Post, Comment)</code> and
generate the following SQL:</p>
<pre><code class="language-sql">SELECT * FROM users
    INNER JOIN posts ON posts.user_id = users.id
    INNER JOIN comments ON comments.user_id = users.id
</code></pre>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1><h3 id="with-implicit-on-clause" class="section-header"><a href="#with-implicit-on-clause">With implicit <code>ON</code> clause</a></h3>
<pre class="rust rust-example-rendered">
<span class="macro">joinable</span><span class="macro">!</span>(<span class="ident">posts</span> <span class="op">-&gt;</span> <span class="ident">users</span> (<span class="ident">user_id</span>));
<span class="macro">allow_tables_to_appear_in_same_query</span><span class="macro">!</span>(<span class="ident">users</span>, <span class="ident">posts</span>);

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">inner_join</span>(<span class="ident">posts</span>)
    .<span class="ident">select</span>((<span class="ident">name</span>, <span class="ident">title</span>))
    .<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);

<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;My first post&quot;</span>)),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;About Rust&quot;</span>)),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Tess&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;My first post too&quot;</span>)),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="ident">expected_data</span>), <span class="ident">data</span>);</pre>
<h3 id="with-explicit-on-clause" class="section-header"><a href="#with-explicit-on-clause">With explicit <code>ON</code> clause</a></h3>
<pre class="rust rust-example-rendered">
<span class="macro">allow_tables_to_appear_in_same_query</span><span class="macro">!</span>(<span class="ident">users</span>, <span class="ident">posts</span>);

<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">posts</span>)
    .<span class="ident">values</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[
        (<span class="ident">user_id</span>.<span class="ident">eq</span>(<span class="number">1</span>), <span class="ident">title</span>.<span class="ident">eq</span>(<span class="string">&quot;Sean&#39;s post&quot;</span>)),
        (<span class="ident">user_id</span>.<span class="ident">eq</span>(<span class="number">2</span>), <span class="ident">title</span>.<span class="ident">eq</span>(<span class="string">&quot;Sean is a jerk&quot;</span>)),
    ])
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)
    .<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">users</span>
    .<span class="ident">inner_join</span>(<span class="ident">posts</span>.<span class="ident">on</span>(<span class="ident">title</span>.<span class="ident">like</span>(<span class="ident">name</span>.<span class="ident">concat</span>(<span class="string">&quot;%&quot;</span>))))
    .<span class="ident">select</span>((<span class="ident">name</span>, <span class="ident">title</span>))
    .<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);
<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&#39;s post&quot;</span>)),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sean is a jerk&quot;</span>)),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="ident">expected_data</span>), <span class="ident">data</span>);</pre>
</div><h3 id='method.left_outer_join' class='method'><span id='left_outer_join.v' class='invisible'><code>fn <a href='#method.left_outer_join' class='fnname'>left_outer_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, LeftOuter&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Join two tables using a SQL <code>LEFT OUTER JOIN</code>.</p>
<p>Behaves similarly to <a href="#method.inner_join"><code>inner_join</code></a>, but will produce a left join
instead. See <a href="#method.inner_join"><code>inner_join</code></a> for usage examples.</p>
</div><h3 id='method.left_join' class='method'><span id='left_join.v' class='invisible'><code>fn <a href='#method.left_join' class='fnname'>left_join</a>&lt;Rhs&gt;(self, rhs: Rhs) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: JoinWithImplicitOnClause&lt;Rhs, LeftOuter&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Alias for <a href="#method.left_outer_join"><code>left_outer_join</code></a>.</p>
</div><h3 id='method.filter' class='method'><span id='filter.v' class='invisible'><code>fn <a href='#method.filter' class='fnname'>filter</a>&lt;Predicate&gt;(self, predicate: Predicate) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: FilterDsl&lt;Predicate&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds to the <code>WHERE</code> clause of a query.</p>
<p>If there is already a <code>WHERE</code> clause, the result will be <code>old AND new</code>.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example:</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">seans_id</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">filter</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Sean&quot;</span>)).<span class="ident">select</span>(<span class="ident">id</span>)
    .<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="ident">seans_id</span>);
<span class="kw">let</span> <span class="ident">tess_id</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">filter</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Tess&quot;</span>)).<span class="ident">select</span>(<span class="ident">id</span>)
    .<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="ident">tess_id</span>);</pre>
</div><h3 id='method.or_filter' class='method'><span id='or_filter.v' class='invisible'><code>fn <a href='#method.or_filter' class='fnname'>or_filter</a>&lt;Predicate&gt;(self, predicate: Predicate) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: OrFilterDsl&lt;Predicate&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds to the <code>WHERE</code> clause of a query using <code>OR</code></p>
<p>If there is already a <code>WHERE</code> clause, the result will be <code>(old OR new)</code>.
Calling <code>foo.filter(bar).or_filter(baz)</code>
is identical to <code>foo.filter(bar.or(baz))</code>.
However, the second form is much harder to do dynamically.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example:</a></h1>
<pre class="rust rust-example-rendered">
<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">animals</span>)
    .<span class="ident">values</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[
        (<span class="ident">species</span>.<span class="ident">eq</span>(<span class="string">&quot;cat&quot;</span>), <span class="ident">legs</span>.<span class="ident">eq</span>(<span class="number">4</span>), <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Sinatra&quot;</span>)),
        (<span class="ident">species</span>.<span class="ident">eq</span>(<span class="string">&quot;dog&quot;</span>), <span class="ident">legs</span>.<span class="ident">eq</span>(<span class="number">3</span>), <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Fido&quot;</span>)),
        (<span class="ident">species</span>.<span class="ident">eq</span>(<span class="string">&quot;spider&quot;</span>), <span class="ident">legs</span>.<span class="ident">eq</span>(<span class="number">8</span>), <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Charlotte&quot;</span>)),
    ])
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">good_animals</span> <span class="op">=</span> <span class="ident">animals</span>
    .<span class="ident">filter</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Fido&quot;</span>))
    .<span class="ident">or_filter</span>(<span class="ident">legs</span>.<span class="ident">eq</span>(<span class="number">4</span>))
    .<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">get_results</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    <span class="prelude-val">Some</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Sinatra&quot;</span>)),
    <span class="prelude-val">Some</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Fido&quot;</span>)),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected</span>, <span class="ident">good_animals</span>);</pre>
</div><h3 id='method.find' class='method'><span id='find.v' class='invisible'><code>fn <a href='#method.find' class='fnname'>find</a>&lt;PK&gt;(self, id: PK) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: FindDsl&lt;PK&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Attempts to find a single record from the given table by primary key.</p>
<h1 id="example-4" class="section-header"><a href="#example-4">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">sean</span> <span class="op">=</span> (<span class="number">1</span>, <span class="string">&quot;Sean&quot;</span>.<span class="ident">to_string</span>());
<span class="kw">let</span> <span class="ident">tess</span> <span class="op">=</span> (<span class="number">2</span>, <span class="string">&quot;Tess&quot;</span>.<span class="ident">to_string</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="ident">sean</span>), <span class="ident">users</span>.<span class="ident">find</span>(<span class="number">1</span>).<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="ident">tess</span>), <span class="ident">users</span>.<span class="ident">find</span>(<span class="number">2</span>).<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Err</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">String</span>), <span class="kw">_</span><span class="op">&gt;</span>(<span class="ident">NotFound</span>), <span class="ident">users</span>.<span class="ident">find</span>(<span class="number">3</span>).<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>));</pre>
</div><h3 id='method.order' class='method'><span id='order.v' class='invisible'><code>fn <a href='#method.order' class='fnname'>order</a>&lt;Expr&gt;(self, expr: Expr) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Expr: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: OrderDsl&lt;Expr&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Sets the order clause of a query.</p>
<p>If there was already a order clause, it will be overridden. See
also:
<a href="../expression_methods/trait.ExpressionMethods.html#method.desc"><code>.desc()</code></a>
and
<a href="../expression_methods/trait.ExpressionMethods.html#method.asc"><code>.asc()</code></a></p>
<p>Ordering by multiple columns can be achieved by passing a tuple of those
columns.
To construct an order clause of an unknown number of columns,
see <a href="#method.then_order_by"><code>QueryDsl::then_order_by</code></a></p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">users</span>)
    .<span class="ident">values</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Saul&quot;</span>),
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Steve&quot;</span>),
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Stan&quot;</span>),
    ])
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">ordered_names</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">order</span>(<span class="ident">name</span>.<span class="ident">desc</span>())
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Stan&quot;</span>, <span class="string">&quot;Saul&quot;</span>], <span class="ident">ordered_names</span>);

<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">users</span>).<span class="ident">values</span>(<span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Stan&quot;</span>)).<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>((<span class="ident">name</span>, <span class="ident">id</span>))
    .<span class="ident">order</span>((<span class="ident">name</span>.<span class="ident">asc</span>(), <span class="ident">id</span>.<span class="ident">desc</span>()))
    .<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Saul&quot;</span>), <span class="number">3</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Stan&quot;</span>), <span class="number">6</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Stan&quot;</span>), <span class="number">5</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Steve&quot;</span>), <span class="number">4</span>),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected_data</span>, <span class="ident">data</span>);</pre>
</div><h3 id='method.order_by' class='method'><span id='order_by.v' class='invisible'><code>fn <a href='#method.order_by' class='fnname'>order_by</a>&lt;Expr&gt;(self, expr: Expr) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Expr: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/expression/trait.Expression.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::expression::Expression">Expression</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: OrderDsl&lt;Expr&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Alias for <code>order</code></p>
</div><h3 id='method.then_order_by' class='method'><span id='then_order_by.v' class='invisible'><code>fn <a href='#method.then_order_by' class='fnname'>then_order_by</a>&lt;Order&gt;(self, order: Order) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: ThenOrderDsl&lt;Order&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Appends to the <code>ORDER BY</code> clause of this SQL query.</p>
<p>Unlike <code>.order</code>, this method will append rather than replace.
In other words,
<code>.order_by(foo).order_by(bar)</code> is equivalent to <code>.order_by(bar)</code>.
In contrast,
<code>.order_by(foo).then_order_by(bar)</code> is equivalent to <code>.order((foo, bar))</code>.
This method is only present on boxed queries.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="ident">diesel</span>::<span class="ident">insert_into</span>(<span class="ident">users</span>)
    .<span class="ident">values</span>(<span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Saul&quot;</span>),
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Steve&quot;</span>),
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Stan&quot;</span>),
        <span class="ident">name</span>.<span class="ident">eq</span>(<span class="string">&quot;Stan&quot;</span>),
    ])
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>((<span class="ident">name</span>, <span class="ident">id</span>))
    .<span class="ident">order_by</span>(<span class="ident">name</span>.<span class="ident">asc</span>())
    .<span class="ident">then_order_by</span>(<span class="ident">id</span>.<span class="ident">desc</span>())
    .<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">expected_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Saul&quot;</span>), <span class="number">3</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Stan&quot;</span>), <span class="number">6</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Stan&quot;</span>), <span class="number">5</span>),
    (<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Steve&quot;</span>), <span class="number">4</span>),
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">expected_data</span>, <span class="ident">data</span>);</pre>
</div><h3 id='method.limit' class='method'><span id='limit.v' class='invisible'><code>fn <a href='#method.limit' class='fnname'>limit</a>(self, limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: LimitDsl,&nbsp;</span></code></span></h3><div class='docblock'><p>Sets the limit clause of the query.</p>
<p>If there was already a limit clause, it will be overridden.</p>
<h1 id="example-5" class="section-header"><a href="#example-5">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="comment">// Using a limit</span>
<span class="kw">let</span> <span class="ident">limited</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">order</span>(<span class="ident">id</span>)
    .<span class="ident">limit</span>(<span class="number">1</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="comment">// Without a limit</span>
<span class="kw">let</span> <span class="ident">no_limit</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">order</span>(<span class="ident">id</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>], <span class="ident">limited</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>, <span class="string">&quot;Bastien&quot;</span>, <span class="string">&quot;Pascal&quot;</span>], <span class="ident">no_limit</span>);</pre>
</div><h3 id='method.offset' class='method'><span id='offset.v' class='invisible'><code>fn <a href='#method.offset' class='fnname'>offset</a>(self, offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: OffsetDsl,&nbsp;</span></code></span></h3><div class='docblock'><p>Sets the offset clause of the query.</p>
<p>If there was already a offset clause, it will be overridden.</p>
<h1 id="example-6" class="section-header"><a href="#example-6">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="comment">// Using an offset</span>
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">order</span>(<span class="ident">id</span>)
    .<span class="ident">limit</span>(<span class="number">2</span>)
    .<span class="ident">offset</span>(<span class="number">1</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="comment">// No Offset</span>
<span class="kw">let</span> <span class="ident">no_offset</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">order</span>(<span class="ident">id</span>)
    .<span class="ident">limit</span>(<span class="number">2</span>)
    .<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Bastien&quot;</span>, <span class="string">&quot;Pascal&quot;</span>], <span class="ident">offset</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Sean&quot;</span>, <span class="string">&quot;Bastien&quot;</span>], <span class="ident">no_offset</span>);</pre>
</div><h3 id='method.for_update' class='method'><span id='for_update.v' class='invisible'><code>fn <a href='#method.for_update' class='fnname'>for_update</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: ForUpdateDsl,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>FOR UPDATE</code> to the end of the select statement.</p>
<p>This method is only available for MySQL and PostgreSQL. SQLite does not
provide any form of row locking.</p>
<p>Additionally, <code>.for_update</code> cannot be used on queries with a distinct
clause, group by clause, having clause, or any unions. Queries with
a <code>FOR UPDATE</code> clause cannot be boxed.</p>
<h1 id="example-7" class="section-header"><a href="#example-7">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR UPDATE`</span>
<span class="ident">users</span>.<span class="ident">for_update</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.for_no_key_update' class='method'><span id='for_no_key_update.v' class='invisible'><code>fn <a href='#method.for_no_key_update' class='fnname'>for_no_key_update</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForNoKeyUpdate&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>FOR NO KEY UPDATE</code> to the end of the select statement.</p>
<p>This method is only available for PostgreSQL. SQLite does not
provide any form of row locking, and MySQL does not support anything
finer than row-level locking.</p>
<p>Additionally, <code>.for_no_key_update</code> cannot be used on queries with a distinct
clause, group by clause, having clause, or any unions. Queries with
a <code>FOR NO KEY UPDATE</code> clause cannot be boxed.</p>
<h1 id="example-8" class="section-header"><a href="#example-8">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR NO KEY UPDATE`</span>
<span class="ident">users</span>.<span class="ident">for_no_key_update</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.for_share' class='method'><span id='for_share.v' class='invisible'><code>fn <a href='#method.for_share' class='fnname'>for_share</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForShare&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>FOR SHARE</code> to the end of the select statement.</p>
<p>This method is only available for MySQL and PostgreSQL. SQLite does not
provide any form of row locking.</p>
<p>Additionally, <code>.for_share</code> cannot be used on queries with a distinct
clause, group by clause, having clause, or any unions. Queries with
a <code>FOR SHARE</code> clause cannot be boxed.</p>
<h1 id="example-9" class="section-header"><a href="#example-9">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR SHARE`</span>
<span class="ident">users</span>.<span class="ident">for_share</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.for_key_share' class='method'><span id='for_key_share.v' class='invisible'><code>fn <a href='#method.for_key_share' class='fnname'>for_key_share</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: LockingDsl&lt;ForKeyShare&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>FOR KEY SHARE</code> to the end of the select statement.</p>
<p>This method is only available for PostgreSQL. SQLite does not
provide any form of row locking, and MySQL does not support anything
finer than row-level locking.</p>
<p>Additionally, <code>.for_key_share</code> cannot be used on queries with a distinct
clause, group by clause, having clause, or any unions. Queries with
a <code>FOR KEY SHARE</code> clause cannot be boxed.</p>
<h1 id="example-10" class="section-header"><a href="#example-10">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR KEY SHARE`</span>
<span class="ident">users</span>.<span class="ident">for_key_share</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.skip_locked' class='method'><span id='skip_locked.v' class='invisible'><code>fn <a href='#method.skip_locked' class='fnname'>skip_locked</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: ModifyLockDsl&lt;SkipLocked&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>SKIP LOCKED</code> to the end of a <code>FOR UPDATE</code> clause.</p>
<p>This modifier is only supported in PostgreSQL 9.5+ and MySQL 8+.</p>
<h1 id="example-11" class="section-header"><a href="#example-11">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR UPDATE SKIP LOCKED`</span>
<span class="ident">users</span>.<span class="ident">for_update</span>().<span class="ident">skip_locked</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.no_wait' class='method'><span id='no_wait.v' class='invisible'><code>fn <a href='#method.no_wait' class='fnname'>no_wait</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: ModifyLockDsl&lt;NoWait&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Adds <code>NOWAIT</code> to the end of a <code>FOR UPDATE</code> clause.</p>
<p>This modifier is only supported in PostgreSQL 9.5+ and MySQL 8+.</p>
<h1 id="example-12" class="section-header"><a href="#example-12">Example</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="comment">// Executes `SELECT * FROM users FOR UPDATE NOWAIT`</span>
<span class="ident">users</span>.<span class="ident">for_update</span>().<span class="ident">no_wait</span>().<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)</pre>
</div><h3 id='method.into_boxed' class='method'><span id='into_boxed.v' class='invisible'><code>fn <a href='#method.into_boxed' class='fnname'>into_boxed</a>&lt;'a, DB&gt;(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;DB: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/backend/trait.Backend.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::backend::Backend">Backend</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: BoxedDsl&lt;'a, DB&gt;,&nbsp;</span></code></span></h3><div class='docblock'><p>Boxes the pieces of a query into a single type.</p>
<p>This is useful for cases where you want to conditionally modify a query,
but need the type to remain the same. The backend must be specified as
part of this. It is not possible to box a query and have it be useable
on multiple backends.</p>
<p>A boxed query will incur a minor performance penalty, as the query builder
can no longer be inlined by the compiler. For most applications this cost
will be minimal.</p>
<h3 id="example-13" class="section-header"><a href="#example-13">Example</a></h3>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="ident">users</span>::<span class="ident">table</span>.<span class="ident">into_boxed</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">name</span>) <span class="op">=</span> <span class="ident">params</span>.<span class="ident">get</span>(<span class="string">&quot;name&quot;</span>) {
    <span class="ident">query</span> <span class="op">=</span> <span class="ident">query</span>.<span class="ident">filter</span>(<span class="ident">users</span>::<span class="ident">name</span>.<span class="ident">eq</span>(<span class="ident">name</span>));
}
<span class="kw">let</span> <span class="ident">users</span> <span class="op">=</span> <span class="ident">query</span>.<span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>);</pre>
<p>Diesel queries also have a similar problem to <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>Iterator</code></a>, where
returning them from a function requires exposing the implementation of that
function. The <a href="../helper_types/index.html"><code>helper_types</code></a> module exists to help with this,
but you might want to hide the return type or have it conditionally change.
Boxing can achieve both.</p>
<h3 id="example-14" class="section-header"><a href="#example-14">Example</a></h3>
<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">users_by_name</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">users</span>::<span class="ident">BoxedQuery</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">DB</span><span class="op">&gt;</span> {
    <span class="ident">users</span>::<span class="ident">table</span>.<span class="ident">filter</span>(<span class="ident">users</span>::<span class="ident">name</span>.<span class="ident">eq</span>(<span class="ident">name</span>)).<span class="ident">into_boxed</span>()
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="ident">users_by_name</span>(<span class="string">&quot;Sean&quot;</span>).<span class="ident">select</span>(<span class="ident">users</span>::<span class="ident">id</span>).<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="ident">users_by_name</span>(<span class="string">&quot;Tess&quot;</span>).<span class="ident">select</span>(<span class="ident">users</span>::<span class="ident">id</span>).<span class="ident">first</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>));</pre>
</div><h3 id='method.single_value' class='method'><span id='single_value.v' class='invisible'><code>fn <a href='#method.single_value' class='fnname'>single_value</a>(self) -&gt; Self::Output <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: SingleValueDsl,&nbsp;</span></code></span></h3><div class='docblock'><p>Wraps this select statement in parenthesis, allowing it to be used
as an expression.</p>
<p>SQL allows queries such as <code>foo = (SELECT ...)</code>, as long as the
subselect returns only a single column, and 0 or 1 rows. This method
indicates that you expect the query to only return a single value (this
will be enforced by adding <code>LIMIT 1</code>).</p>
<p>The SQL type of this will always be <code>Nullable</code>, as the query returns
<code>NULL</code> if the table is empty or it otherwise returns 0 rows.</p>
<h1 id="example-15" class="section-header"><a href="#example-15">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="ident">insert_into</span>(<span class="ident">posts</span>::<span class="ident">table</span>)
    .<span class="ident">values</span>(<span class="ident">posts</span>::<span class="ident">user_id</span>.<span class="ident">eq</span>(<span class="number">1</span>))
    .<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">last_post</span> <span class="op">=</span> <span class="ident">posts</span>::<span class="ident">table</span>
    .<span class="ident">order</span>(<span class="ident">posts</span>::<span class="ident">id</span>.<span class="ident">desc</span>());
<span class="kw">let</span> <span class="ident">most_recently_active_user</span> <span class="op">=</span> <span class="ident">users</span>.<span class="ident">select</span>(<span class="ident">name</span>)
    .<span class="ident">filter</span>(<span class="ident">id</span>.<span class="ident">nullable</span>().<span class="ident">eq</span>(<span class="ident">last_post</span>.<span class="ident">select</span>(<span class="ident">posts</span>::<span class="ident">user_id</span>).<span class="ident">single_value</span>()))
    .<span class="ident">first</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">connection</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Sean&quot;</span>, <span class="ident">most_recently_active_user</span>);</pre>
</div></div><h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><ul class='item-list' id='implementors-list'><li><table class='table-display'><tbody><tr><td><code>impl&lt;T&gt; QueryDsl for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../../../../../oration/schema/threads/columns/_impl_query_id_for_title/diesel/query_source/trait.Table.html" title="trait oration::schema::threads::columns::_impl_query_id_for_title::diesel::query_source::Table">Table</a>,&nbsp;</span></code><td></td></tr></tbody></table></li>
</ul><script type="text/javascript">window.inlined_types=new Set([]);</script><script type="text/javascript" async
                         src="../../../../../../implementors/diesel/query_dsl/trait.QueryDsl.js">
                 </script></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../../../../";window.currentCrate = "oration";</script><script src="../../../../../../aliases.js"></script><script src="../../../../../../main.js"></script><script defer src="../../../../../../search-index.js"></script></body></html>